---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "heading_lvl",
                                 "i_subtitle",
                                 "i_title",
                                 "is_heading_ignored",
                                 "is_help_topic",
                                 "subnode_ix"))
```

## Constants

### `this_pkg`

```{r}
this_pkg <- utils::packageName()
```

### `data_special_headings`

```{r}
data_special_headings <- tibble::tribble(
  
  ~type,          ~heading_texts,  ~meaning,
  "description",  "DESCRIPTION",   paste0("Paragraph(s) below this heading, that in turn is hierarchically below a `title` or `subtitle` heading, are used as ",
                                          "the description for this very (sub)title (`desc` in the pkgdown reference index)."),
  "ignore_title", "EXPORTED",      paste0("Will never be used as `title` or `subtitle` in the pkgdown reference index (i.e. ignored). Simply serves as a ",
                                         "(usually top-level) heading to indicate that the objects defined below it are ",
                                         "[exported](https://r-pkgs.org/namespace.html#exports) by the package."),
  "ignore_content", c("INTERNAL",
                      "NOTES",
                      "TEMPORARY",
                      "TMP"),      paste0("Everything that's hierarchically below one of these headings is completely ignored for pkgdown reference index ",
                                          "generation.")
)
```

Pre-assign each heading type to a character vector variable for optimal performance.

```{r}
# somehow `envir = parent.frame(4)` doesn't assign in the right environment, so we explicitly provide it
pkg_env <- rlang::current_env()

data_special_headings %>%
  dplyr::group_split(type) %>%
  purrr::walk(~ assign(x = paste0("heading_texts_", .x$type),
                       value = purrr::list_c(.x$heading_texts,
                                             ptype = character()),
                       envir = pkg_env))
rm(pkg_env)
```

## Functions

### `assemble_copyright_notice`

Assemble a package's copyright notice

```{r}
assemble_copyright_notice <- function(path) {
  
  pal::assert_pkg("desc")
  if (fs::is_dir(path)) {
    path <- fs::path(path, "DESCRIPTION")
  }
  notice <- character()
  
  if (desc::desc_has_fields(keys = "Authors@R",
                            file = path)) {
    
    pkg <- pal::desc_value(key = "Package",
                           file = path)
    desc <- pal::desc_value(key = "Title",
                            default = "",
                            file = path)
    authors <-
      desc::desc_get_authors(file = path) %>%
      # reduce to copyright holders or otherwise authors
      pal::when(any(purrr::map_lgl(., ~ "cph" %in% .x$role)) ~ purrr::keep(., ~ "cph" %in% .x$role),
                any(purrr::map_lgl(., ~ "aut" %in% .x$role)) ~ purrr::keep(., ~ "aut" %in% .x$role),
                ~ .) %>%
      format(include = c("given", "family")) %>%
      pal::prose_ls()
    
    if (length(authors) > 0L) {
      
      notice <- c(paste0(pkg, ": ", desc),
                  paste0("Copyright (C) ", format(Sys.Date(), "%Y"), "  ", authors))
      
    } else {
      cli::cli_alert_warning(paste0("Neither copyright holders nor authors found in {.field Authors@R} field in the package's {.file DESCRIPTION} file, thus ",
                                    "skipped adding copyright notice."))
    }
      
  } else {
    cli::cli_alert_warning(paste0("No {.field Authors@R} field present in the package's {.file DESCRIPTION} file, thus skipped adding license notice.",
                                  paste0(" Try converting the existing {.field Author} field to an {.field Authors@R} field using {.fun ",
                                         "desc::desc_coerce_authors_at_r}.")[desc::desc_has_fields("Author")]))
  }
  
  notice
}
```

### `assemble_license_notice`

Assemble a package's license notice

```{r}
assemble_license_notice <- function(path) {
  
  pal::assert_pkg("desc")
  notice <- character()
  if (fs::is_dir(path)) path <- fs::path(path, "DESCRIPTION")
  
  if (desc::desc_has_fields(keys = "License",
                            file = path)) {
    
    license <- pal::desc_value(key = "License",
                               file = path)
    
    if (grepl(x = license,
              pattern = "^\\s*(AGPL ?\\(>= ?3\\)|AGPL-3\\.0-or-later)\\s*$")) {
      
      notice <- c(paste0("This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as ",
                         "published by the Free Software Foundation, either version 3 of the License, or any later version."),
                  paste0("This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of ",
                         "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details."),
                  paste0("You should have received a copy of the GNU Affero General Public License along with this program. If not, see",
                         " <https://www.gnu.org/licenses/>."))
        
    } else {
      cli::cli_alert_warning(paste0("{.field License} field in the package's {.file DESCRIPTION} file is not set to {.val AGPL (>= 3)}, thus skipped adding ",
                                    "license notice."))
    }
    
  } else {
    cli::cli_alert_warning("No {.field License} field present in the package's {.file DESCRIPTION} file, thus skipped adding license notice.")
  }
  
  notice
}
```

### `document_pkg`

Builds a package's roxygen2 documentation.

```{r}
document_pkg <- function(path,
                         ...) {
  
  cli::cli_progress_step(msg = "Building package documentation")
  
  devtools::document(pkg = path,
                     ...)
  
  cli::cli_progress_done()
}
```

### `extract_md_heading_content`

Removes leading `#`s and trailing newlines.

```{r}
extract_md_heading_content <- function(x) {
  
  x %>%
    stringr::str_remove(pattern = "^#+") %>%
    stringr::str_trim() %>%
    purrr::map_chr(~ {
      if (.x == "") NA_character_ else .x
    })
}
```

### `install_pkg`

```{r}
install_pkg <- function(path,
                        unload = FALSE,
                        quiet = FALSE,
                        ...) {
  
  cli::cli_progress_step(msg = "Building and installing package")
  pkg_name <- pkgload::pkg_name(path)
  
  # unregister pkg if it's attached
  if (pkg_name %in% loadedNamespaces()) {
    
    if (unload) {
      pkgload::unload(package = pkg_name,
                      quiet = quiet)
    } else {
      pkgload::unregister(package = pkg_name)
    }
  }
  
  devtools::install(pkg = path,
                    quiet = quiet,
                    ...)
  
  cli::cli_progress_done()
}
```

### `install_pkg_rstudio_api`

```{r}
install_pkg_rstudio_api <- function(quiet = FALSE) {
  
  cli::cli_alert_info("Building and installing package via RStudio API (see the {.strong Build} pane)")
  
  rstudioapi::executeCommand(commandId = "buildFull",
                             quiet = quiet)
}
```

### `main_rmd`

```{r}
#' Determine a package's main `.Rmd` source file
#'
#' Determines which R Markdown file under `Rmd/` in `path` is the package's main source file. If multiple `.Rmd` files are present, the one whose name matches
#' the package name is selected.
#'
#' @inheritParams purl_rmd
#'
#' @return A character vector, of length 1 if a main `.Rmd` is found, otherwise of length 0.
#' @keywords internal
#' @export
main_rmd <- function(path = ".") {
  
  rmd_file_paths <- rmd_files(path = path)
  n_rmd_file_paths <- length(rmd_file_paths)
  
  if (!n_rmd_file_paths) {
    
    cli::cli_abort("No {.file .Rmd} files found under {.arg path}.")
    
  } else if (n_rmd_file_paths == 1L) {
    
    result <- rmd_file_paths
    
  } else {
    
    result <-
      rmd_file_paths %>%
      fs::path_file() %>%
      fs::path_ext_remove() %>%
      magrittr::is_in(pal::desc_value(key = "Package",
                                      file = path)) %>%
      which() %>%
      magrittr::extract(rmd_file_paths, .) %>%
      pal::when(length(.) > 1L ~ # this is theoretically possible in case of subdirs under `Rmd/` or for case-sensitive filesystems (both `.Rmd` and `.rmd`)
                  cli::cli_abort(paste0("Multiple {.file .Rmd} files detected under {.path {fs::path(path, 'Rmd/')}} whose names match the package name: ",
                                        "{.file {.}}")),
                ~ .)
  }
  
  result
}
```

### `normalize_md_lf`

Replaces single line feeds (`"\n"`) with whitespaces (`" "`), except for a trailing line feed.

```{r}
normalize_md_lf <- function(x) {
  
  stringr::str_replace_all(string = x,
                           pattern = "(?<!\\n)\\n(?!(\\n|$))",
                           replacement = " ")
}
```

### `process_rmd`

Helper function purling a single file `Rmd/*.Rmd` to `R/*.gen.R`.

NOTES:

-   Subdirs under `R/` are not allowed, so we flatten output path hierarchy, c.f. <https://r-pkgs.org/r.html#code-organising> (footnote 14).

```{r}
process_rmd <- function(path_file,
                        path_pkg,
                        copyright_notice,
                        license_notice,
                        line_width = 160L) {
  r_file_path <-
    path_file %>%
    fs::path_file() %>%
    fs::path_ext_set(ext = ".gen.R") %>%
    fs::path(path_pkg, "R", .)
  
  knitr::purl(input = path_file,
              output = r_file_path,
              quiet = TRUE,
              documentation = 0L)
  
  # add reminder header lines to generated R file
  result <-
    path_file %>%
    fs::path_rel(start = fs::path_dir(fs::path_dir(.))) %>%
    paste0("DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `", ., "` and run `pkgpurl::purl_rmd()`.") %>%
    pal::as_comment_string("See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.",
                           sep_paragraphs = FALSE) %>%
    # add copyright and license notices if indicated
    paste0("\n",
           if (length(copyright_notice) > 0L) {
             copyright_notice %>% pal::as_comment_string("", sep_paragraphs = FALSE)
           },
           if (length(license_notice) > 0L) {
             license_notice %>% pal::as_comment_string() %>% paste0("\n")
           },
           brio::read_file(path = r_file_path))
  
  brio::write_file(text = result,
                   path = r_file_path)
}
```

### `restart_r`

```{r}
restart_r <- function() {
  
  pal::assert_pkg("rstudioapi")
  
  if (rstudioapi::isAvailable()) {
    rstudioapi::restartSession()
  } else {
    cli::cli_alert_warning("Unable to restart R session because it is running outside of RStudio.")
  }
}
```

### `rmd_files`

```{r}
rmd_files <- function(path) {
  
  checkmate::assert_directory_exists(path,
                                     access = "r")
  checkmate::assert_scalar(path)
  
  fs::path(path, "Rmd") %>%
    fs::path_abs() %>%
    fs::dir_ls(recurse = TRUE,
               type = "file",
               regexp = "(?<!\\.nopurl)\\.[Rr]md$",
               perl = TRUE)
}
```

# EXPORTED

## High-level functions

### `process_pkg`

TODO:

-   Once it's possible to [interact with RStudio's *Build* pane via pkg rstudioapi](https://github.com/rstudio/rstudioapi/issues/17), we should test printing
    `process_pkg()`'s output to it instead of the console.

NOTES:

-   There's a [longstanding bug in R](https://bugs.r-project.org/show_bug.cgi?id=16644) that causes `process_pkg()` to fail with an error "lazy-load database
    ... is corrupt".

```{r}
#' Process R Markdown package from source to installation
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Executes all steps to process an R package written in R Markdown format from source to installation in one go:
#'
#' 1. Purl all relevant `Rmd/*.Rmd` files to `R/*.gen.R` files using [purl_rmd()].
#' 2. Re-generate the [pkgdown reference index](https://pkgdown.r-lib.org/reference/build_reference.html#reference-index) based on the package's [main R
#'    Markdown file][main_rmd()] using [gen_pkgdown_ref()] (if `gen_pkgdown_ref = TRUE`).
#' 3. Re-build the package documentation using [devtools::document()] (if `document = TRUE`).
#' 4. Build and install the package (if `build_and_install = TRUE`). This is done either using
#'    [`rstudioapi::executeCommand(commandId = "buildFull")`][rstudioapi::executeCommand] (if `use_rstudio_api = TRUE`) or using [devtools::install()] (if
#'    `use_rstudio_api = FALSE`)
#' 5. Restarts the R session using [rstudioapi::restartSession()] (if `restart_r_session = TRUE`).
#'
#' @details
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#'
#' @inheritParams purl_rmd
#' @inheritParams devtools::document
#' @inheritParams devtools::install
#' @param document Whether or not to re-build the package documentation after purling `Rmd/*.Rmd` to `R/*.gen.R`.
#' @param build_and_install Whether or not to build and install the package after purling `Rmd/*.Rmd` to `R/*.gen.R`.
#' @param restart_r_session Whether or not to restart the R session. Highly recommended if `build_and_install = TRUE`, but only possible when R is run within
#'   RStudio. Note that the R session is always restarted if `use_rstudio_api = TRUE`.
#' @param use_rstudio_api Whether or not to rely on the RStudio API to install the built package (which also triggers an R session restart). If `NULL`, it is
#'   automatically set based on whether RStudio is running (`TRUE`) or not (`FALSE`).
#' @param quiet `r pkgsnip::param_label("quiet")`
#'
#' @inherit purl_rmd return
#' @family high_lvl
#' @export
process_pkg <- function(path = ".",
                        add_copyright_notice = pal::pkg_config_val(key = "add_copyright_notice",
                                                                   pkg = this_pkg,
                                                                   default = TRUE),
                        add_license_notice = pal::pkg_config_val(key = "add_license_notice",
                                                                 pkg = this_pkg,
                                                                 default = TRUE),
                        gen_pkgdown_ref = pal::pkg_config_val(key = "gen_pkgdown_ref",
                                                              pkg = this_pkg,
                                                              default = TRUE),
                        document = TRUE,
                        build_and_install = TRUE,
                        restart_r_session = build_and_install,
                        use_rstudio_api = NULL,
                        quiet = TRUE,
                        roclets = NULL,
                        args = getOption("devtools.install.args"),
                        dependencies = NA,
                        upgrade = "never",
                        keep_source = getOption("keep.source.pkgs")) {
  
  checkmate::assert_flag(document)
  checkmate::assert_flag(build_and_install)
  checkmate::assert_flag(restart_r_session)
  checkmate::assert_flag(use_rstudio_api,
                         null.ok = TRUE)
  checkmate::assert_flag(quiet)
  pal::assert_pkg("devtools")
  pal::assert_pkg("pkgload")
  
  if (is.null(use_rstudio_api) && nzchar(system.file(package = "rstudioapi")) && rstudioapi::isAvailable()) {
    use_rstudio_api <- TRUE
  } else {
    use_rstudio_api <- use_rstudio_api %||% FALSE
  }
  
  # convert `Rmd/*.Rmd` to `R/*.gen.R`
  purl_rmd(path = path,
           add_copyright_notice = add_copyright_notice,
           add_license_notice = add_license_notice,
           gen_pkgdown_ref = gen_pkgdown_ref)
  
  # build roxygen2 documentation
  if (document) {
    document_pkg(path = path,
                 roclets = roclets,
                 quiet = quiet)
  }
  
  # build and install package
  if (build_and_install) {
    
    if (use_rstudio_api) {
      install_pkg_rstudio_api(quiet = quiet)
    } else {
      install_pkg(path = path,
                  unload = FALSE,
                  quiet = quiet,
                  reload = TRUE,
                  args = args,
                  dependencies = dependencies,
                  upgrade = upgrade,
                  keep_source = keep_source)
      
      if (restart_r_session) {
        restart_r()
      }
    }
  }
  
  invisible(path)
}
```

### `load_pkg`

```{r}
#' Load R Markdown package
#'
#' @description
#' Executes the steps to load an R package written in R Markdown format in one go:
#'
#' 1. Purl all relevant `Rmd/*.Rmd` files to `R/*.gen.R` files using [purl_rmd()].
#' 2. Loads the package using [devtools::load_all()].
#'
#' @inheritParams purl_rmd
#' @inheritParams devtools::load_all
#'
#' @inherit purl_rmd return
#' @family high_lvl
#' @export
load_pkg <- function(path = ".",
                     add_copyright_notice = pal::pkg_config_val(key = "add_copyright_notice",
                                                                pkg = this_pkg,
                                                                default = TRUE),
                     add_license_notice = pal::pkg_config_val(key = "add_license_notice",
                                                              pkg = this_pkg,
                                                              default = TRUE),
                     gen_pkgdown_ref = pal::pkg_config_val(key = "gen_pkgdown_ref",
                                                           pkg = this_pkg,
                                                           default = FALSE),
                     reset = TRUE,
                     recompile = FALSE,
                     export_all = TRUE,
                     helpers = TRUE,
                     quiet = FALSE,
                     ...) {
  
  pal::assert_pkg("devtools")
  
  # convert `Rmd/*.Rmd` to `R/*.gen.R`
  purl_rmd(path = path,
           add_copyright_notice = add_copyright_notice,
           add_license_notice = add_license_notice,
           gen_pkgdown_ref = gen_pkgdown_ref)
  
  # load pkg
  devtools::load_all(path = path,
                     reset = reset,
                     recompile = recompile,
                     export_all = export_all,
                     helpers = helpers,
                     quiet = quiet,
                     ...)
  invisible(path)
}
```

### `purl_rmd`

The basic workflow is heavily inspired by a pertinent makefile from Yihui Xie found [here](https://yihui.org/rlp/#from-rmd-to-r). Not least because I'm a
complete noob regarding [makefile syntax](https://en.wikipedia.org/wiki/Makefile), I decided to write the relevant pieces in R.

TODO:

-   [ ] Support more OSS licenses in param `add_license_notice` / fn `assemble_license_notice()`. Default license headers would have to be systematically
    fetched from somewhere for this!

    Notable stuff:

    -   There's an [Open Source License API by the OSI](https://github.com/OpenSourceOrg/api/blob/master/doc/endpoints.md); maybe create an API wrapper pkg for
        R? (unfortunately, default license headers don't seem to be included in the data returned by the API (yet))

    -   There's the [Software Package Data Exchange (SPDX)](https://spdx.org/licenses/) project by the Linux Foundation systematically offering license
        information in a standardized format and defining unique license identifiers (SPDX IDs); an individual license page can be accessed under the URL
        `https://spdx.org/licenses/[SPDX-ID].html`; it seems to always include a section *Standard License Header* 🎉 (which just says "There is no standard
        license header for the license" if there's none).

        Maybe we should add the [`SPDX-License-Identifier` and `SPDX-FileCopyrightText` tags](https://reuse.software/tutorial/#step-2) to the generated R files
        besides the license header and instead of the current copyright notice?

    Viable solution:

    1.  Determine a package license's SPDX identifier. If the OSI API would offer any (fuzzy) search endpoint, we could feed the license info in the pkg
        DESCRIPTION to the OSI API and query the SPDX identifier. But the OSI API doesn't seem to ... so at least we need to implement a mapping from the
        [license identifiers officially supported by R](https://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Licensing) (like the "standard" short
        specifications) to the SPDX identifiers!

    2.  Based on the SPDX identifier, scrape the SPDX page for the *Standard License Header* section.

```{r}
#' Purl `Rmd/*.Rmd` to `R/*.gen.R`
#'
#' This function strives to provide a standardized way to convert all relevant `.Rmd` files in the `Rmd/` subdirectory to bare `.R` files in the `R/`
#' subdirectory using [knitr::purl()]. It is mainly intended for authoring R packages in the [R Markdown file format](https://rmarkdown.rstudio.com/).
#'
#' The generated `.R` files will be named the same as the `.Rmd` files plus the suffix `.gen` to indicate the file was auto-generated. So the file
#' `Rmd/foo.Rmd` for example will be converted to `R/foo.gen.R`.
#'
#' The R Markdown file format allows you to intermingle code with related prose in [Markdown syntax](https://bookdown.org/yihui/rmarkdown/markdown-syntax.html)
#' optimized for human readability. This facilitates (best) practices which are commonly referred to as
#' [_literate programming_](https://en.wikipedia.org/wiki/Literate_programming).
#' 
#' In practice, the main advantage of writing R code in R Markdown is that you don't have to rely on
#' [`#` comments](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Comments) to explain, annotate or otherwise elaborate on your code. It also
#' allows you to easily compile your source code to beautifully looking HTML, PDF etc. files using [rmarkdown::render()].
#'
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#' 
#' # `.Rmd` files excluded from purling
#' 
#' `purl_rmd()` does not generate an `.R` file for each and every R Markdown file in the `Rmd/` subdirectory. Two types of `.Rmd` files are excluded from
#' purling:
#' 
#' 1. Files having the suffix `.nopurl` in their name, e.g. `Rmd/playground.nopurl.Rmd`.
#' 2. Hidden files [as per Unix convention](https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory#Unix_and_Unix-like_environments) whose names start
#'    with a dot, e.g. `Rmd/.playground.Rmd`.
#' 
#' The above convention allows for easy exclusion of specific `.Rmd` files from purling. A common case for this are scripts that generate [package-internal
#' data](https://r-pkgs.org/data.html#data-sysdata) from raw sources. Such a script could be stored as `Rmd/data.nopurl.Rmd`, so that no corresponding file
#' under `R/*.R` is generated. For the sake of clarity, it's generally advised to prefer the `.nopurl` suffix over hiding files.
#'
#' @param path Path to the root of the package directory.
#' @param add_copyright_notice `r pkg_config$description[pkg_config$key == "add_copyright_notice"]` A logical scalar. Only applies if `path` [is actually an R
#'   package directory][pal::is_pkg_dir].
#' @param add_license_notice `r pkg_config$description[pkg_config$key == "add_license_notice"]` A logical scalar. Only applies if `path` [is actually an R
#'   package directory][pal::is_pkg_dir].
#' @param gen_pkgdown_ref `r pkg_config$description[pkg_config$key == "gen_pkgdown_ref"]` A logical scalar. Only applies if `path` [is actually an R package
#'   directory][pal::is_pkg_dir], [pkgdown is set up][pal::is_pkgdown_dir] and a [main R Markdown file][main_rmd()] exists.
#'
#' @return `path`, invisibly.
#' @family high_lvl
#' @export
purl_rmd <- function(path = ".",
                     add_copyright_notice = pal::pkg_config_val(key = "add_copyright_notice",
                                                                pkg = this_pkg,
                                                                default = TRUE),
                     add_license_notice = pal::pkg_config_val(key = "add_license_notice",
                                                              pkg = this_pkg,
                                                              default = TRUE),
                     gen_pkgdown_ref = pal::pkg_config_val(key = "gen_pkgdown_ref",
                                                           pkg = this_pkg,
                                                           default = TRUE)) {
  
  checkmate::assert_flag(add_copyright_notice)
  checkmate::assert_flag(add_license_notice)
  checkmate::assert_flag(gen_pkgdown_ref)
  
  rmd_files <- rmd_files(path = path)
  
  if (length(rmd_files) > 0L) {
    
    cli::cli_progress_step(msg = "Purling {.file Rmd/*.Rmd} to {.file R/*.gen.R}")
    
    r_dir <- fs::path(path, "R/")
    if (!fs::dir_exists(r_dir)) fs::dir_create(r_dir)
    copyright_notice <- NULL
    license_notice <- NULL
    
    if (pal::is_pkg_dir(path)) {
      
      add_copyright_notice <- add_copyright_notice %||% TRUE
      add_license_notice <- add_license_notice %||% TRUE
      if (add_copyright_notice) copyright_notice <- assemble_copyright_notice(path = path)
      if (add_license_notice) license_notice <- assemble_license_notice(path = path)
      
      if (gen_pkgdown_ref && pal::is_pkgdown_dir(path)) {
        
        # determine pkgdown config file path
        pkgdown_config_file <-
          c("_pkgdown.yml",
            "_pkgdown.yaml",
            "pkgdown/_pkgdown.yml",
            "pkgdown/_pkgdown.yaml",
            "inst/_pkgdown.yml",
            "inst/_pkgdown.yaml") %>%
          fs::path(path, .) %>%
          fs::file_exists() %>%
          magrittr::extract(which(.)[1L]) %>%
          names()
        
        # determine main input file for pkgdown reference generation
        main_rmd_file <- main_rmd(path = path)
        gen_pkgdown_ref <- length(main_rmd_file) > 0L
        
      } else {
        gen_pkgdown_ref <- FALSE
      }
      
    } else {
      
      impossible_opts <- c("add_copyright_notice"[isTRUE(add_copyright_notice)],
                           "add_license_notice"[isTRUE(add_license_notice)])
      n_impossible_opts <- length(impossible_opts)
      
      if (n_impossible_opts) {
        cli::cli_abort(paste0("{.arg {impossible_opts[1L]}} ",
                              "and {.arg {impossible_opts[2L]}} "[n_impossible_opts > 1L],
                              "{qty(n_impossible_opts)} {?was/were both} set to {.val TRUE}, but {.file {path}} does not appear to be an R package ",
                              "directory \u2013 thus cannot extract the necessary information from the package's {.file DESCRIPTION} file."))
      }
      
      add_copyright_notice <- FALSE
      add_license_notice <- FALSE
      gen_pkgdown_ref <- FALSE
    }
    
    rmd_files %>% purrr::walk(process_rmd,
                              path_pkg = path,
                              copyright_notice = copyright_notice,
                              license_notice = license_notice)
    
    if (gen_pkgdown_ref) {
      
      ref <-
        main_rmd_file %>%
        brio::read_file() %>%
        gen_pkgdown_ref()
      
      if (length(ref$reference) > 0L) {
        
        yaml::read_yaml(file = pkgdown_config_file) %>%
          purrr::discard_at(at = "reference") %>%
          c(ref) %>%
          yaml::write_yaml(file = pkgdown_config_file)
      }
    }
    
  } else {
    cli::cli_alert_warning("{.path {path}} does not appear to be an Rmd package directory. Nothing done.")
  }
  
  invisible(path)
}
```

### `lint_rmd`

**Notes:**

-   For some reason, `lintr::lint_dir(".")` excludes all of the generated `.gen.R` files out of the box. Maybe because their first line starts with
    `# DO NOT EDIT THIS FILE BY HAND! ...`?

    If in the future they won't be excluded anymore for some reason, a sensible way to run lintr on the whole package dir seems:

    ``` r
    lintr::lint_dir(path = ".",
                    pattern = "\\.[Rr]([Mm][Dd])?$",
                    exclusions = list.files(path = "R",
                                            recursive = TRUE,
                                            full.names = TRUE,
                                            pattern = "\\.gen\\.R$"))
    ```

```{r}
#' Lint R Markdown package
#'
#' This is a convenience wrapper around [lintr::lint_dir()] which is tailored to a typical R Markdown package. To use this function, the
#' [lintr](https://github.com/jimhester/lintr/#readme) package is required.
#'
#' To avoid unnecessary noise, all the the generated `R/*.gen.R` files as well as R Markdown vignettes under `vignettes/*.Rmd` are excluded from linting.
#'
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#'
#' @param excl_vignettes Whether to exclude all `.Rmd` files under `vignettes/`. A logical scalar.
#' @inheritParams purl_rmd
#'
#' @inherit lintr::lint_dir return
#' @family high_lvl
#' @export
lint_rmd <- function(path = ".",
                     excl_vignettes = TRUE) {
  
  checkmate::assert_directory_exists(path,
                                     access = "r")
  checkmate::assert_flag(excl_vignettes)
  pal::assert_pkg("lintr")
  
  lintr::lint_dir(path = path,
                  pattern = "\\.[Rr]([Mm][Dd])?$",
                  exclusions = list(c(list.files(path = "R",
                                                 recursive = TRUE,
                                                 full.names = TRUE,
                                                 pattern = "\\.gen\\.R$"),
                                      list.files(path = "vignettes",
                                                 recursive = TRUE,
                                                 full.names = TRUE,
                                                 pattern = "\\.Rmd$")[!excl_vignettes])))
}
```

### `run_nopurl_rmd`

```{r}
#' Run `*.nopurl.Rmd` files
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Executes `.Rmd` files which are supposed to contain code not included in the [source
#' package](https://r-pkgs.org/package-structure-state.html#source-package), i.e. usually outsourced to separate `.Rmd` files with the [`.nopurl` suffix in
#' their filenames](https://pkgpurl.rpkg.dev/dev/reference/purl_rmd.html#-rmd-files-excluded-from-purling). Those files are typically used to generate package
#' data.
#'
#' If an error is encountered saying `internal error -3 in R_decompress1`, restart the R session and run again.
#'
#' @inheritParams purl_rmd
#' @inheritParams devtools::document
#' @inheritParams devtools::install
#' @param path_rmd Path(s) to the `.Rmd` files to be executed. A character vector.
#' @param env Environment to evaluate the `.Rmd` files in. If `NULL`, the [global environment][globalenv] is used.
#' @param document Whether or not to re-build the package documentation after the last `.Rmd` file is executed.
#' @param build_and_install Whether or not to build and install the package after each `.Rmd` file execution.
#' @param restart_r_session Whether or not to restart the R session after the last `.Rmd` file is executed. Highly recommended if `build_and_install = TRUE`,
#'   but only possible when R is run within RStudio.
#'
#' @return `path_rmd`, invisibly.
#' @family high_lvl
#' @export
run_nopurl_rmd <- function(path = ".",
                           path_rmd = fs::dir_ls(path = fs::path(path, "Rmd"),
                                                 recurse = TRUE,
                                                 type = "file",
                                                 glob = "*.nopurl.Rmd"),
                           env = NULL,
                           document = TRUE,
                           build_and_install = TRUE,
                           restart_r_session = TRUE,
                           quiet = TRUE,
                           roclets = NULL,
                           args = getOption("devtools.install.args"),
                           dependencies = NA,
                           upgrade = "never",
                           keep_source = getOption("keep.source.pkgs")) {
  
  checkmate::assert_directory_exists(path,
                                     access = "r")
  checkmate::assert_scalar(path)
  checkmate::assert_file_exists(path_rmd,
                                access = "r",
                                extension = c("Rmd", "qmd"))
  checkmate::assert_environment(env,
                                null.ok = TRUE)
  checkmate::assert_flag(document)
  checkmate::assert_flag(build_and_install)
  checkmate::assert_flag(restart_r_session)
  
  path_tmp_purled <-
    path_rmd %>%
    purrr::map_chr(~ knitr::purl(input = .x,
                                 output = fs::file_temp(pattern = fs::path_ext_remove(fs::path_file(.x)),
                                                        ext = "R"),
                                 quiet = quiet))
  
  for (i in seq_along(path_tmp_purled)) {
    
    cli::cli_progress_step(msg = "{.strong Executing file {.file {path_tmp_purled[i]}}}")
    
    source(file = path_tmp_purled[i],
           local = ifelse(is.null(env),
                          FALSE,
                          env),
           echo = FALSE,
           encoding = "UTF-8")
    
    cli::cli_progress_done()
    
    is_last_path <- i == length(path_tmp_purled)
    
    # build roxygen2 documentation
    if (document && is_last_path) {
      document_pkg(path = path,
                   roclets = roclets,
                   quiet = quiet)
    }
    
    if (build_and_install) {
      install_pkg(path = path,
                  unload = TRUE,
                  quiet = quiet,
                  reload = TRUE,
                  quick = !document || !is_last_path,
                  build = TRUE,
                  args = args,
                  dependencies = dependencies,
                  upgrade = upgrade,
                  keep_source = keep_source)
    }
  }
  
  fs::file_delete(path_tmp_purled)
  
  if (restart_r_session) {
    restart_r()
  }
  
  invisible(path_rmd)
}
```

## Low-level functions

### `gen_pkgdown_ref`

NOTES:

-   The pkgdown reference supports a max. of 2 hierarchy levels.

-   Use `desc: |` YAML syntax to preserve linebreaks and thus allow multi-paragraph descriptions.

-   For a sophisticated pkgdown reference example, see the one of [ggplot2](https://ggplot2.tidyverse.org/reference/index.html) (and compare with its
    [source](https://github.com/tidyverse/ggplot2/blob/master/_pkgdown.yml)).

```{r}
#' Generate pkgdown reference index
#'
#' @description
#' Generates the [pkgdown reference index](https://pkgdown.r-lib.org/reference/build_reference.html#reference-index) based on the heading hierarchy structure of
#' a package's main `.Rmd` file.
#'
#' @details
#' Basically, all elements of the pkgdown reference index except `desc` keys are derived from `rmd`'s [Markdown
#' **headings**](https://pandoc.org/MANUAL.html#headings) and their **hierarchy**. The `desc` keys, however, are assembled from the paragraph(s) below some
#' specially named headings. See below for details.
#'
#' # Special headings
#' 
#' Headings that exactly match certain strings (case-insensitive, but without any inline formatting or additional text) are treated specially. Here's an
#' overview:
#'
#' ```{r, results = "asis", echo = FALSE}
#' data_special_headings %>%
#'   dplyr::select(-type) %>%
#'   dplyr::rename(Headings = heading_texts,
#'                 Meaning = meaning) %>%
#'   pal::pipe_table()
#' ```
#'
#' # Parsing rules
#'
#' To be able to unambiguously map an `.Rmd` file's heading hierarchy to the pkgdown reference index, some parsing rules are necessary. Attention must be paid
#' to the fact that, while (R) Markdown supports up to six heading levels (corresponding to HTML's `<h1>`–`<h6>` tags), the pkgdown reference index only
#' supports up to two (`title` and `subtitle`).
#' 
#' The following rules define how the reference index is generated:
#' 
#' 1. Headings below a heading named
#'    `r purrr::list_c(dplyr::filter(data_special_headings, type == "ignore_content")$heading_texts, ptype = character()) %>% pal::prose_ls(wrap = "*", last_sep = " or ")`
#'    (case-insensitive, but without any inline formatting) are simply ignored when generating the reference index.
#' 2. Every heading that is a) inline-formatted as [verbatim](https://pandoc.org/MANUAL.html#verbatim) and b) doesn't contain any whitespace characters is
#'    considered to be the name of a help topic (usually the name of a function or dataset) to be included in the reference index. This maps to the `contents`
#'    key of the reference index' YAML.
#' 3. Non-help-topic headings above help topic headings are used as reference index (sub)titles as far as hierarchical nesting allows. More precisely,
#'    non-help-topic headings *of the highest two levels* above the help topic heading are used as title and subtitle, the rest of the headings above the help
#'    topic heading is ignored – and a heading named *EXPORTED* (case-insensitive, but without any inline formatting) is always ignored regardless of its
#'    level. This maps to the `title` and `subtitle` keys of the reference index' YAML.
#' 4. Paragraph(s) below a heading named *DESCRIPTION* (case-insensitive, but without any inline formatting), that in turn is hierarchically below a title or
#'    subtitle heading, are used as the description for the respective (sub)title. This maps to the `desc` key of the reference index' YAML.
#'
#' # Parsing example
#'
#' An example might better explain how the parsing rules work than a thousand words, so here's a simplified one.
#' 
#' When fed to `gen_pkgdown_ref()`, the following R Markdown content...
#'
#' ```{r, results = "asis", echo = FALSE}
#' brio::read_lines("snippets/simplified_example.Rmd") %>%
#'   c(paste(pal::as_string(rep("`", 4L)), "rmd"), ., pal::as_string(rep("`", 4L))) %>%
#'   pal::cat_lines()
#' ```
#'
#' ...yields this pkgdown index (converted [to YAML][yaml::as.yaml()]):
#'
#' ```{r, comment = "", echo = FALSE}
#' brio::read_file("snippets/simplified_example.Rmd") %>%
#'   gen_pkgdown_ref() %>%
#'   yaml::as.yaml() %>%
#'   cat()
#' ```
#'
#' @param rmd The (R) Markdown file content as a character scalar.
#'
#' @return A list.
#' @family low_lvl
#' @export
#'
#' @examples
#' pal::gh_text_file(path = "Rmd/pal.Rmd",
#'                   owner = "salim-b",
#'                   name = "pal") |>
#'   pkgpurl::gen_pkgdown_ref() |>
#'   yaml::as.yaml() |>
#'   cat()
gen_pkgdown_ref <- function(rmd) {
  
  checkmate::assert_string(rmd)
  pal::assert_pkg("xml2")
  
  rmd_xml <-
    rmd %>%
    pal::md_to_xml(strip_xml_ns = FALSE) %>%
    xml2::xml_contents()
  
  # assemble necessary Markdown heading hierarchy information (one row for each node of `rmd_xml`)
  hierarchy <-
    tibble::tibble(subnode_ix = pal::md_xml_subnode_ix(xml = rmd_xml),
                   # is *relevant* heading
                   is_heading =
                     subnode_ix %>%
                     purrr::map_int(length) %>%
                     magrittr::is_greater_than(0L)) %>%
    tibble::rowid_to_column(var = "i") %>%
    # add variables that are relevant for heading nodes only
    dplyr::left_join(y = tibble::tibble(i = .$i[.$is_heading],
                                        heading_lvl =
                                          rmd_xml[i] %>%
                                          purrr::map_chr(xml2::xml_attr,
                                                         attr = "level") %>%
                                          as.integer(),
                                        is_help_topic =
                                          xml2::xml_length(rmd_xml[i]) == 1L
                                        & rmd_xml[i] %>%
                                          xml2::xml_child(search = "d1:code") %>%
                                          xml2::xml_text() %>%
                                          stringr::str_detect(pattern = "^[^\\s`]+$"),
                                        is_description_heading =
                                          xml2::xml_length(rmd_xml[i]) == 1L
                                        & rmd_xml[i] %>%
                                          xml2::xml_child(search = "d1:text") %>%
                                          xml2::xml_text(trim = TRUE) %>%
                                          stringr::str_detect(pattern =
                                                                heading_texts_description %>%
                                                                pal::fuse_regex() %>%
                                                                paste0("^(?i)", ., "$")),
                                        is_ignored =
                                          xml2::xml_length(rmd_xml[i]) == 1L
                                        & rmd_xml[i] %>%
                                          xml2::xml_child(search = "d1:text") %>%
                                          xml2::xml_text(trim = TRUE) %>%
                                          stringr::str_detect(pattern =
                                                                heading_texts_ignore_content %>%
                                                                pal::fuse_regex() %>%
                                                                paste0("^(?i)", ., "$")),
                                        is_heading_ignored =
                                          xml2::xml_length(rmd_xml[i]) == 1L
                                        & rmd_xml[i] %>%
                                          xml2::xml_child(search = "d1:text") %>%
                                          xml2::xml_text(trim = TRUE) %>%
                                          stringr::str_detect(pattern =
                                                                heading_texts_ignore_title %>%
                                                                pal::fuse_regex() %>%
                                                                paste0("^(?i)", ., "$"))),
                     by = "i") %>%
    tidyr::replace_na(replace = list(is_help_topic = FALSE,
                                     is_description_heading = FALSE))
  ## complete `is_ignored`
  for (i in hierarchy$i[hierarchy$is_ignored
                        & !is.na(hierarchy$is_ignored)
                        & purrr::map_int(hierarchy$subnode_ix, length) > 0L]) {
    
    hierarchy$is_ignored[unlist(hierarchy$subnode_ix[i])] <- TRUE
  }
  hierarchy %<>% tidyr::replace_na(replace = list(is_ignored = FALSE))
  ## exclude ignored help topics
  hierarchy$is_help_topic[hierarchy$is_ignored] <- FALSE
  
  # warn if no valid help topic nodes are present
  if (!length(which(hierarchy$is_help_topic))) {
    
    cli::cli_alert_warning("Unable to generate pkgdown reference index. No valid help topic headings found in main {.file .Rmd} file.")
    
    result <- list()
    
  } else {
    
    # initialize reference index data
    data_ref_i <- tibble::tibble(i_title = integer(),
                                 i_subtitle = integer(),
                                 content = character())
    
    # iterate over all help topic nodes, get their names as well as their (sub)title node indices
    for (i in hierarchy$i[hierarchy$is_help_topic]) {
      
      hierarchy_subset <-
        hierarchy %>%
        dplyr::filter(!is_help_topic
                      & !is_heading_ignored
                      & hierarchy$subnode_ix %>% purrr::map_lgl(~ !!i %in% .x))
      
      title_lvl <- pal::safe_min(hierarchy_subset$heading_lvl)
      
      data_ref_i %<>% tibble::add_row(i_title =
                                        hierarchy_subset %>%
                                        dplyr::filter(heading_lvl == title_lvl) %$%
                                        ifelse(length(i) > 0L,
                                               as.integer(i),
                                               NA_integer_),
                                      i_subtitle =
                                        hierarchy_subset %>%
                                        dplyr::filter(heading_lvl > title_lvl) %>%
                                        dplyr::filter(heading_lvl == pal::safe_min(heading_lvl)) %$%
                                        ifelse(length(i) > 0L,
                                               as.integer(i),
                                               NA_integer_),
                                      content = xml2::xml_text(rmd_xml[i]))
    }
    
    # add actual (sub)titles and their descriptions
    data_ref_i %<>%
      dplyr::left_join(y = tibble::tibble(i_title =
                                            .$i_title %>%
                                            unique() %>%
                                            setdiff(NA_integer_),
                                          title =
                                            rmd_xml[i_title] %>%
                                            purrr::map_chr(pal::xml_to_md) %>%
                                            extract_md_heading_content(),
                                          title_description =
                                            hierarchy$subnode_ix[i_title] %>%
                                            purrr::map2_chr(.y = i_title,
                                                            .f = ~
                                                              hierarchy[.x, ] %>%
                                                              dplyr::filter(is_description_heading
                                                                            & heading_lvl == hierarchy$heading_lvl[.y] + 1L) %$%
                                                              subnode_ix %>%
                                                              purrr::list_c(ptype = integer()) %>%
                                                              magrittr::extract(rmd_xml, .) %>%
                                                              purrr::map_chr(pal::xml_to_md) %>%
                                                              stringr::str_trim() %>%
                                                              pal::when(length(.) > 0L ~ paste0(., collapse = "\n\n"),
                                                                        ~ NA_character_))),
                       by = "i_title") %>%
      dplyr::left_join(y = tibble::tibble(i_subtitle =
                                            .$i_subtitle %>%
                                            unique() %>%
                                            setdiff(NA_integer_),
                                          subtitle =
                                            rmd_xml[i_subtitle] %>%
                                            purrr::map_chr(pal::xml_to_md) %>%
                                            extract_md_heading_content(),
                                          subtitle_description =
                                            hierarchy$subnode_ix[i_subtitle] %>%
                                            purrr::map2_chr(.y = i_subtitle,
                                                            .f = ~
                                                              hierarchy[.x, ] %>%
                                                              dplyr::filter(is_description_heading
                                                                            & heading_lvl == hierarchy$heading_lvl[.y] + 1L) %$%
                                                              subnode_ix %>%
                                                              purrr::list_c(ptype = integer()) %>%
                                                              magrittr::extract(rmd_xml, .) %>%
                                                              purrr::map_chr(pal::xml_to_md) %>%
                                                              stringr::str_trim() %>%
                                                              pal::when(length(.) > 0L ~ paste0(., collapse = "\n\n"),
                                                                        ~ NA_character_))),
                       by = "i_subtitle")
    
    # assemble result list that can easily be converted to YAML using `yaml::as.yaml()`
    result <-
      data_ref_i %>%
      dplyr::group_by(i_title) %>%
      dplyr::group_map(function(data_title, key) {
        
        title <- data_title$title[1L]
        title_description <- data_title$title_description[1L]
        item_title <- list()
        
        if (!is.na(title)) {
          item_title %<>% c(list(title = title))
        }
        if (!is.na(title_description)) {
          item_title %<>% c(list(desc = title_description))
        }
        
        items_subtitle <-
          data_title %>%
          dplyr::group_by(i_subtitle) %>%
          dplyr::group_map(function(data_subtitle, key) {
            
            subtitle <- data_subtitle$subtitle[1L]
            subtitle_description <- data_subtitle$subtitle_description[1L]
            contents <- data_subtitle$content
            item_subtitle <- list()
            
            if (!is.na(subtitle)) {
              item_subtitle %<>% c(list(subtitle = subtitle))
            }
            if (!is.na(subtitle_description)) {
              item_subtitle %<>% c(list(desc = subtitle_description))
            }
            
            c(list(item_subtitle),
              list(list(contents = contents)))
          }) %>%
          purrr::list_flatten() %>%
          purrr::compact() %>%
          # move subtitle-less item to the front (the `NA` group is always processed last in `group_map()`)
          pal::when(anyNA(data_title$subtitle) ~ .[c(length(.), seq_len(length(.) - 1L))],
                    ~ .)
        
        c(list(item_title),
          items_subtitle)
      }) %>%
      purrr::list_flatten() %>%
      purrr::compact() %>%
      # move title-less item to the front (the `NA` group is always processed last in `group_map()`)
      pal::when(anyNA(data_ref_i$title) ~ .[c(length(.), seq_len(length(.) - 1L))],
                ~ .)
  }
  
  list(reference = result)
}
```

## Miscellaneous

### `pkg_config`

```{r}
#' `r pkgsnip::title_label("pkg_config", pkg = "pkgpurl")`
#'
#' `r pkgsnip::description_label("pkg_config", pkg = "pkgpurl")`
#'
#' @format `r pkgsnip::return_label("data_cols", cols = colnames(pkg_config))`
#' @export
#'
#' @examples
#' pkgpurl::pkg_config
pkg_config <-
  tibble::tibble(key = character(),
                 default_value = list(),
                 description = character()) %>%
  tibble::add_row(key = "add_copyright_notice",
                  description = paste0("Whether or not to add a **copyright notice** at the beginning of the generated `.R` files as recommended by e.g. the ",
                                       "[GNU licenses](https://www.gnu.org/licenses/gpl-howto.html). The notice consists of the name and description of the ",
                                       "program and the word `Copyright (C)` followed by the release years and the name(s) of the copyright holder(s), or if ",
                                       "not specified, the author(s). The year is always the current year. All the other information is extracted from the ",
                                       "package's `DESCRIPTION` file.")) %>%
  tibble::add_row(key = "add_license_notice",
                  description = paste0("Whether or not to add a **license notice** at the beginning of the generated `.R` files as recommended by e.g. the ",
                                       "[GNU licenses](https://www.gnu.org/licenses/gpl-howto.html). The license is determined from the package's ",
                                       "`DESCRIPTION` file and currently only the [`AGPL-3.0-or-later` ",
                                       "license](https://spdx.org/licenses/AGPL-3.0-or-later.html) is supported.")) %>%
  tibble::add_row(key = "gen_pkgdown_ref",
                  description = paste0("Whether or not to overwrite [pkgdown][pkgdown::pkgdown-package]'s [reference ",
                                       "index](https://pkgdown.r-lib.org/reference/build_reference.html#reference-index) in the configuration file ",
                                       "`_pkgdown.yml` with an auto-generated one based on the main input file as described in [gen_pkgdown_ref()]."))
```
